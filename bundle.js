!function(t){var r={};function n(e){if(r[e])return r[e].exports;var a=r[e]={i:e,l:!1,exports:{}};return t[e].call(a.exports,a,a.exports,n),a.l=!0,a.exports}n.m=t,n.c=r,n.d=function(t,r,e){n.o(t,r)||Object.defineProperty(t,r,{enumerable:!0,get:e})},n.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},n.t=function(t,r){if(1&r&&(t=n(t)),8&r)return t;if(4&r&&"object"==typeof t&&t&&t.__esModule)return t;var e=Object.create(null);if(n.r(e),Object.defineProperty(e,"default",{enumerable:!0,value:t}),2&r&&"string"!=typeof t)for(var a in t)n.d(e,a,function(r){return t[r]}.bind(null,a));return e},n.n=function(t){var r=t&&t.__esModule?function(){return t.default}:function(){return t};return n.d(r,"a",r),r},n.o=function(t,r){return Object.prototype.hasOwnProperty.call(t,r)},n.p="",n(n.s=13)}([function(t,r){t.exports=function(t){function r(t){"undefined"!=typeof console&&(console.error||console.log)("[Script Loader]",t)}try{"undefined"!=typeof execScript&&"undefined"!=typeof attachEvent&&"undefined"==typeof addEventListener?execScript(t):"undefined"!=typeof eval?eval.call(null,t):r("EvalError: No eval function available")}catch(t){r(t)}}},function(t,r,n){t.exports=n.p+"images/creating_gif_wait.3cfef4a964288750b1c7f1dc8dbe866c.png"},function(t,r,n){t.exports=n.p+"images/delete_frame.2330cba898c73fa51f86df2ea000f279.png"},function(t,r,n){},function(t,r,n){},function(t,r,n){n(0)(n(6))},function(t,r){t.exports="/**\r\n * This class handles LZW encoding\r\n * Adapted from Jef Poskanzer's Java port by way of J. M. G. Elliott.\r\n * @author Kevin Weiner (original Java version - kweiner@fmsware.com)\r\n * @author Thibault Imbert (AS3 version - bytearray.org)\r\n * @author Kevin Kwok (JavaScript version - https://github.com/antimatter15/jsgif)\r\n * @version 0.1 AS3 implementation\r\n */\r\n\r\nLZWEncoder = function() {\r\n\r\n\tvar exports = {};\r\n\tvar EOF = -1;\r\n\tvar imgW;\r\n\tvar imgH;\r\n\tvar pixAry;\r\n\tvar initCodeSize;\r\n\tvar remaining;\r\n\tvar curPixel;\r\n\r\n\t// GIFCOMPR.C - GIF Image compression routines\r\n\t// Lempel-Ziv compression based on 'compress'. GIF modifications by\r\n\t// David Rowley (mgardi@watdcsu.waterloo.edu)\r\n\t// General DEFINEs\r\n\r\n\tvar BITS = 12;\r\n\tvar HSIZE = 5003; // 80% occupancy\r\n\r\n\t// GIF Image compression - modified 'compress'\r\n\t// Based on: compress.c - File compression ala IEEE Computer, June 1984.\r\n\t// By Authors: Spencer W. Thomas (decvax!harpo!utah-cs!utah-gr!thomas)\r\n\t// Jim McKie (decvax!mcvax!jim)\r\n\t// Steve Davies (decvax!vax135!petsd!peora!srd)\r\n\t// Ken Turkowski (decvax!decwrl!turtlevax!ken)\r\n\t// James A. Woods (decvax!ihnp4!ames!jaw)\r\n\t// Joe Orost (decvax!vax135!petsd!joe)\r\n\r\n\tvar n_bits; // number of bits/code\r\n\tvar maxbits = BITS; // user settable max # bits/code\r\n\tvar maxcode; // maximum code, given n_bits\r\n\tvar maxmaxcode = 1 << BITS; // should NEVER generate this code\r\n\tvar htab = [];\r\n\tvar codetab = [];\r\n\tvar hsize = HSIZE; // for dynamic table sizing\r\n\tvar free_ent = 0; // first unused entry\r\n\r\n\t// block compression parameters -- after all codes are used up,\r\n\t// and compression rate changes, start over.\r\n\r\n\tvar clear_flg = false;\r\n\r\n\t// Algorithm: use open addressing double hashing (no chaining) on the\r\n\t// prefix code / next character combination. We do a variant of Knuth's\r\n\t// algorithm D (vol. 3, sec. 6.4) along with G. Knott's relatively-prime\r\n\t// secondary probe. Here, the modular division first probe is gives way\r\n\t// to a faster exclusive-or manipulation. Also do block compression with\r\n\t// an adaptive reset, whereby the code table is cleared when the compression\r\n\t// ratio decreases, but after the table fills. The variable-length output\r\n\t// codes are re-sized at this point, and a special CLEAR code is generated\r\n\t// for the decompressor. Late addition: construct the table according to\r\n\t// file size for noticeable speed improvement on small files. Please direct\r\n\t// questions about this implementation to ames!jaw.\r\n\r\n\tvar g_init_bits;\r\n\tvar ClearCode;\r\n\tvar EOFCode;\r\n\r\n\t// output\r\n\t// Output the given code.\r\n\t// Inputs:\r\n\t// code: A n_bits-bit integer. If == -1, then EOF. This assumes\r\n\t// that n_bits =< wordsize - 1.\r\n\t// Outputs:\r\n\t// Outputs code to the file.\r\n\t// Assumptions:\r\n\t// Chars are 8 bits long.\r\n\t// Algorithm:\r\n\t// Maintain a BITS character long buffer (so that 8 codes will\r\n\t// fit in it exactly). Use the VAX insv instruction to insert each\r\n\t// code in turn. When the buffer fills up empty it and start over.\r\n\r\n\tvar cur_accum = 0;\r\n\tvar cur_bits = 0;\r\n\tvar masks = [0x0000, 0x0001, 0x0003, 0x0007, 0x000F, 0x001F, 0x003F, 0x007F, 0x00FF, 0x01FF, 0x03FF, 0x07FF, 0x0FFF, 0x1FFF, 0x3FFF, 0x7FFF, 0xFFFF];\r\n\r\n\t// Number of characters so far in this 'packet'\r\n\tvar a_count;\r\n\r\n\t// Define the storage for the packet accumulator\r\n\tvar accum = [];\r\n\r\n\tvar LZWEncoder = exports.LZWEncoder = function LZWEncoder(width, height, pixels, color_depth) {\r\n\t\timgW = width;\r\n\t\timgH = height;\r\n\t\tpixAry = pixels;\r\n\t\tinitCodeSize = Math.max(2, color_depth);\r\n\t};\r\n\r\n\t// Add a character to the end of the current packet, and if it is 254\r\n\t// characters, flush the packet to disk.\r\n\tvar char_out = function char_out(c, outs) {\r\n\t\taccum[a_count++] = c;\r\n\t\tif (a_count >= 254) flush_char(outs);\r\n\t};\r\n\r\n\t// Clear out the hash table\r\n\t// table clear for block compress\r\n\r\n\tvar cl_block = function cl_block(outs) {\r\n\t\tcl_hash(hsize);\r\n\t\tfree_ent = ClearCode + 2;\r\n\t\tclear_flg = true;\r\n\t\toutput(ClearCode, outs);\r\n\t};\r\n\r\n\t// reset code table\r\n\tvar cl_hash = function cl_hash(hsize) {\r\n\t\tfor (var i = 0; i < hsize; ++i) htab[i] = -1;\r\n\t};\r\n\r\n\tvar compress = exports.compress = function compress(init_bits, outs) {\r\n\r\n\t\tvar fcode;\r\n\t\tvar i; /* = 0 */\r\n\t\tvar c;\r\n\t\tvar ent;\r\n\t\tvar disp;\r\n\t\tvar hsize_reg;\r\n\t\tvar hshift;\r\n\r\n\t\t// Set up the globals: g_init_bits - initial number of bits\r\n\t\tg_init_bits = init_bits;\r\n\r\n\t\t// Set up the necessary values\r\n\t\tclear_flg = false;\r\n\t\tn_bits = g_init_bits;\r\n\t\tmaxcode = MAXCODE(n_bits);\r\n\r\n\t\tClearCode = 1 << (init_bits - 1);\r\n\t\tEOFCode = ClearCode + 1;\r\n\t\tfree_ent = ClearCode + 2;\r\n\r\n\t\ta_count = 0; // clear packet\r\n\r\n\t\tent = nextPixel();\r\n\r\n\t\thshift = 0;\r\n\t\tfor (fcode = hsize; fcode < 65536; fcode *= 2)\r\n\t\t\t++hshift;\r\n\t\thshift = 8 - hshift; // set hash code range bound\r\n\r\n\t\thsize_reg = hsize;\r\n\t\tcl_hash(hsize_reg); // clear hash table\r\n\r\n\t\toutput(ClearCode, outs);\r\n\r\n\t\touter_loop: while ((c = nextPixel()) != EOF) {\r\n\t\t\tfcode = (c << maxbits) + ent;\r\n\t\t\ti = (c << hshift) ^ ent; // xor hashing\r\n\r\n\t\t\tif (htab[i] == fcode) {\r\n\t\t\t\tent = codetab[i];\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\telse if (htab[i] >= 0) { // non-empty slot\r\n\r\n\t\t\t\tdisp = hsize_reg - i; // secondary hash (after G. Knott)\r\n\t\t\t\tif (i === 0) disp = 1;\r\n\r\n\t\t\t\tdo {\r\n\t\t\t\t\tif ((i -= disp) < 0)\r\n\t\t\t\t\t\ti += hsize_reg;\r\n\r\n\t\t\t\t\tif (htab[i] == fcode) {\r\n\t\t\t\t\t\tent = codetab[i];\r\n\t\t\t\t\t\tcontinue outer_loop;\r\n\t\t\t\t\t}\r\n\t\t\t\t} while (htab[i] >= 0);\r\n\t\t\t}\r\n\r\n\t\t\toutput(ent, outs);\r\n\t\t\tent = c;\r\n\t\t\tif (free_ent < maxmaxcode) {\r\n\t\t\t\tcodetab[i] = free_ent++; // code -> hashtable\r\n\t\t\t\thtab[i] = fcode;\r\n\t\t\t}\r\n\t\t\telse cl_block(outs);\r\n\t\t}\r\n\r\n\t\t// Put out the final code.\r\n\t\toutput(ent, outs);\r\n\t\toutput(EOFCode, outs);\r\n\t};\r\n\r\n\t// ----------------------------------------------------------------------------\r\n\tvar encode = exports.encode = function encode(os) {\r\n\t\tos.writeByte(initCodeSize); // write \"initial code size\" byte\r\n\t\tremaining = imgW * imgH; // reset navigation variables\r\n\t\tcurPixel = 0;\r\n\t\tcompress(initCodeSize + 1, os); // compress and write the pixel data\r\n\t\tos.writeByte(0); // write block terminator\r\n\t};\r\n\r\n\t// Flush the packet to disk, and reset the accumulator\r\n\tvar flush_char = function flush_char(outs) {\r\n\t\tif (a_count > 0) {\r\n\t\t\touts.writeByte(a_count);\r\n\t\t\touts.writeBytes(accum, 0, a_count);\r\n\t\t\ta_count = 0;\r\n\t\t}\r\n\t};\r\n\r\n\tvar MAXCODE = function MAXCODE(n_bits) {\r\n\t\treturn (1 << n_bits) - 1;\r\n\t};\r\n\r\n\t// ----------------------------------------------------------------------------\r\n\t// Return the next pixel from the image\r\n\t// ----------------------------------------------------------------------------\r\n\r\n\tvar nextPixel = function nextPixel() {\r\n\t\tif (remaining === 0) return EOF;\r\n\t\t--remaining;\r\n\t\tvar pix = pixAry[curPixel++];\r\n\t\treturn pix & 0xff;\r\n\t};\r\n\r\n\tvar output = function output(code, outs) {\r\n\r\n\t\tcur_accum &= masks[cur_bits];\r\n\r\n\t\tif (cur_bits > 0) cur_accum |= (code << cur_bits);\r\n\t\telse cur_accum = code;\r\n\r\n\t\tcur_bits += n_bits;\r\n\r\n\t\twhile (cur_bits >= 8) {\r\n\t\t\tchar_out((cur_accum & 0xff), outs);\r\n\t\t\tcur_accum >>= 8;\r\n\t\t\tcur_bits -= 8;\r\n\t\t}\r\n\r\n\t\t// If the next entry is going to be too big for the code size,\r\n\t\t// then increase it, if possible.\r\n\r\n\t\tif (free_ent > maxcode || clear_flg) {\r\n\r\n\t\t\tif (clear_flg) {\r\n\r\n\t\t\t\tmaxcode = MAXCODE(n_bits = g_init_bits);\r\n\t\t\t\tclear_flg = false;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t++n_bits;\r\n\t\t\t\tif (n_bits == maxbits) maxcode = maxmaxcode;\r\n\t\t\t\telse maxcode = MAXCODE(n_bits);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (code == EOFCode) {\r\n\r\n\t\t\t// At EOF, write the rest of the buffer.\r\n\t\t\twhile (cur_bits > 0) {\r\n\t\t\t\tchar_out((cur_accum & 0xff), outs);\r\n\t\t\t\tcur_accum >>= 8;\r\n\t\t\t\tcur_bits -= 8;\r\n\t\t\t}\r\n\r\n\t\t\tflush_char(outs);\r\n\t\t}\r\n\t};\r\n\r\n\tLZWEncoder.apply(this, arguments);\r\n\treturn exports;\r\n};\r\n"},function(t,r,n){n(0)(n(8))},function(t,r){t.exports='/*\r\n * NeuQuant Neural-Net Quantization Algorithm\r\n * ------------------------------------------\r\n *\r\n * Copyright (c) 1994 Anthony Dekker\r\n *\r\n * NEUQUANT Neural-Net quantization algorithm by Anthony Dekker, 1994. See\r\n * "Kohonen neural networks for optimal colour quantization" in "Network:\r\n * Computation in Neural Systems" Vol. 5 (1994) pp 351-367. for a discussion of\r\n * the algorithm.\r\n *\r\n * Any party obtaining a copy of these files from the author, directly or\r\n * indirectly, is granted, free of charge, a full and unrestricted irrevocable,\r\n * world-wide, paid up, royalty-free, nonexclusive right and license to deal in\r\n * this software and documentation files (the "Software"), including without\r\n * limitation the rights to use, copy, modify, merge, publish, distribute,\r\n * sublicense, and/or sell copies of the Software, and to permit persons who\r\n * receive copies from any such party to do so, with the only requirement being\r\n * that this copyright notice remain intact.\r\n */\r\n\r\n/*\r\n * This class handles Neural-Net quantization algorithm\r\n * @author Kevin Weiner (original Java version - kweiner@fmsware.com)\r\n * @author Thibault Imbert (AS3 version - bytearray.org)\r\n * @author Kevin Kwok (JavaScript version - https://github.com/antimatter15/jsgif)\r\n * @version 0.1 AS3 implementation\r\n */\r\n\r\nNeuQuant = function() {\r\n\r\n\tvar exports = {};\r\n\tvar netsize = 256; /* number of colours used */\r\n\r\n\t/* four primes near 500 - assume no image has a length so large */\r\n\t/* that it is divisible by all four primes */\r\n\r\n\tvar prime1 = 499;\r\n\tvar prime2 = 491;\r\n\tvar prime3 = 487;\r\n\tvar prime4 = 503;\r\n\tvar minpicturebytes = (3 * prime4); /* minimum size for input image */\r\n\r\n\t/*\r\n\t * Program Skeleton ---------------- [select samplefac in range 1..30] [read\r\n\t * image from input file] pic = (unsigned char*) malloc(3*width*height);\r\n\t * initnet(pic,3*width*height,samplefac); learn(); unbiasnet(); [write output\r\n\t * image header, using writecolourmap(f)] inxbuild(); write output image using\r\n\t * inxsearch(b,g,r)\r\n\t */\r\n\r\n\t/*\r\n\t * Network Definitions -------------------\r\n\t */\r\n\r\n\tvar maxnetpos = (netsize - 1);\r\n\tvar netbiasshift = 4; /* bias for colour values */\r\n\tvar ncycles = 100; /* no. of learning cycles */\r\n\r\n\t/* defs for freq and bias */\r\n\tvar intbiasshift = 16; /* bias for fractions */\r\n\tvar intbias = (1 << intbiasshift);\r\n\tvar gammashift = 10; /* gamma = 1024 */\r\n\tvar gamma = (1 << gammashift);\r\n\tvar betashift = 10;\r\n\tvar beta = (intbias >> betashift); /* beta = 1/1024 */\r\n\tvar betagamma = (intbias << (gammashift - betashift));\r\n\r\n\t/* defs for decreasing radius factor */\r\n\tvar initrad = (netsize >> 3); /* for 256 cols, radius starts */\r\n\tvar radiusbiasshift = 6; /* at 32.0 biased by 6 bits */\r\n\tvar radiusbias = (1 << radiusbiasshift);\r\n\tvar initradius = (initrad * radiusbias); /* and decreases by a */\r\n\tvar radiusdec = 30; /* factor of 1/30 each cycle */\r\n\r\n\t/* defs for decreasing alpha factor */\r\n\tvar alphabiasshift = 10; /* alpha starts at 1.0 */\r\n\tvar initalpha = (1 << alphabiasshift);\r\n\tvar alphadec; /* biased by 10 bits */\r\n\r\n\t/* radbias and alpharadbias used for radpower calculation */\r\n\tvar radbiasshift = 8;\r\n\tvar radbias = (1 << radbiasshift);\r\n\tvar alpharadbshift = (alphabiasshift + radbiasshift);\r\n\tvar alpharadbias = (1 << alpharadbshift);\r\n\r\n\t/*\r\n\t * Types and Global Variables --------------------------\r\n\t */\r\n\r\n\tvar thepicture; /* the input image itself */\r\n\tvar lengthcount; /* lengthcount = H*W*3 */\r\n\tvar samplefac; /* sampling factor 1..30 */\r\n\r\n\t// typedef int pixel[4]; /* BGRc */\r\n\tvar network; /* the network itself - [netsize][4] */\r\n\tvar netindex = [];\r\n\r\n\t/* for network lookup - really 256 */\r\n\tvar bias = [];\r\n\r\n\t/* bias and freq arrays for learning */\r\n\tvar freq = [];\r\n\tvar radpower = [];\r\n\r\n\tvar NeuQuant = exports.NeuQuant = function NeuQuant(thepic, len, sample) {\r\n\r\n\t\tvar i;\r\n\t\tvar p;\r\n\r\n\t\tthepicture = thepic;\r\n\t\tlengthcount = len;\r\n\t\tsamplefac = sample;\r\n\r\n\t\tnetwork = new Array(netsize);\r\n\r\n\t\tfor (i = 0; i < netsize; i++) {\r\n\r\n\t\t\tnetwork[i] = new Array(4);\r\n\t\t\tp = network[i];\r\n\t\t\tp[0] = p[1] = p[2] = (i << (netbiasshift + 8)) / netsize;\r\n\t\t\tfreq[i] = intbias / netsize; /* 1/netsize */\r\n\t\t\tbias[i] = 0;\r\n\t\t}\r\n\t};\r\n\r\n\tvar colorMap = function colorMap() {\r\n\r\n\t\tvar map = [];\r\n\t\tvar index = new Array(netsize);\r\n\r\n\t\tfor (var i = 0; i < netsize; i++)\r\n\t\t\tindex[network[i][3]] = i;\r\n\r\n\t\tvar k = 0;\r\n\t\tfor (var l = 0; l < netsize; l++) {\r\n\t\t\tvar j = index[l];\r\n\t\t\tmap[k++] = (network[j][0]);\r\n\t\t\tmap[k++] = (network[j][1]);\r\n\t\t\tmap[k++] = (network[j][2]);\r\n\t\t}\r\n\r\n\t\treturn map;\r\n\t};\r\n\r\n\t/*\r\n\t * Insertion sort of network and building of netindex[0..255] (to do after\r\n\t * unbias)\r\n\t * -------------------------------------------------------------------------------\r\n\t */\r\n\r\n\tvar inxbuild = function inxbuild() {\r\n\r\n\t\tvar i;\r\n\t\tvar j;\r\n\t\tvar smallpos;\r\n\t\tvar smallval;\r\n\t\tvar p;\r\n\t\tvar q;\r\n\t\tvar previouscol;\r\n\t\tvar startpos;\r\n\r\n\t\tpreviouscol = 0;\r\n\t\tstartpos = 0;\r\n\t\tfor (i = 0; i < netsize; i++) {\r\n\r\n\t\t\tp = network[i];\r\n\t\t\tsmallpos = i;\r\n\t\t\tsmallval = p[1]; /* index on g */\r\n\r\n\t\t\t/* find smallest in i..netsize-1 */\r\n\t\t\tfor (j = i + 1; j < netsize; j++) {\r\n\r\n\t\t\t\tq = network[j];\r\n\t\t\t\tif (q[1] < smallval) { /* index on g */\r\n\t\t\t\t\tsmallpos = j;\r\n\t\t\t\t\tsmallval = q[1]; /* index on g */\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tq = network[smallpos];\r\n\r\n\t\t\t/* swap p (i) and q (smallpos) entries */\r\n\t\t\tif (i != smallpos) {\r\n\t\t\t\tj = q[0];\r\n\t\t\t\tq[0] = p[0];\r\n\t\t\t\tp[0] = j;\r\n\t\t\t\tj = q[1];\r\n\t\t\t\tq[1] = p[1];\r\n\t\t\t\tp[1] = j;\r\n\t\t\t\tj = q[2];\r\n\t\t\t\tq[2] = p[2];\r\n\t\t\t\tp[2] = j;\r\n\t\t\t\tj = q[3];\r\n\t\t\t\tq[3] = p[3];\r\n\t\t\t\tp[3] = j;\r\n\t\t\t}\r\n\r\n\t\t\t/* smallval entry is now in position i */\r\n\r\n\t\t\tif (smallval != previouscol) {\r\n\r\n\t\t\t\tnetindex[previouscol] = (startpos + i) >> 1;\r\n\r\n\t\t\t\tfor (j = previouscol + 1; j < smallval; j++) netindex[j] = i;\r\n\r\n\t\t\t\tpreviouscol = smallval;\r\n\t\t\t\tstartpos = i;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tnetindex[previouscol] = (startpos + maxnetpos) >> 1;\r\n\t\tfor (j = previouscol + 1; j < 256; j++) netindex[j] = maxnetpos; /* really 256 */\r\n\t};\r\n\r\n\t/*\r\n\t * Main Learning Loop ------------------\r\n\t */\r\n\r\n\tvar learn = function learn() {\r\n\r\n\t\tvar i;\r\n\t\tvar j;\r\n\t\tvar b;\r\n\t\tvar g;\r\n\t\tvar r;\r\n\t\tvar radius;\r\n\t\tvar rad;\r\n\t\tvar alpha;\r\n\t\tvar step;\r\n\t\tvar delta;\r\n\t\tvar samplepixels;\r\n\t\tvar p;\r\n\t\tvar pix;\r\n\t\tvar lim;\r\n\r\n\t\tif (lengthcount < minpicturebytes) samplefac = 1;\r\n\r\n\t\talphadec = 30 + ((samplefac - 1) / 3);\r\n\t\tp = thepicture;\r\n\t\tpix = 0;\r\n\t\tlim = lengthcount;\r\n\t\tsamplepixels = lengthcount / (3 * samplefac);\r\n\t\tdelta = (samplepixels / ncycles) | 0;\r\n\t\talpha = initalpha;\r\n\t\tradius = initradius;\r\n\r\n\t\trad = radius >> radiusbiasshift;\r\n\t\tif (rad <= 1) rad = 0;\r\n\r\n\t\tfor (i = 0; i < rad; i++) radpower[i] = alpha * (((rad * rad - i * i) * radbias) / (rad * rad));\r\n\r\n\t\tif (lengthcount < minpicturebytes) step = 3;\r\n\r\n\t\telse if ((lengthcount % prime1) !== 0) step = 3 * prime1;\r\n\r\n\t\telse {\r\n\r\n\t\t\tif ((lengthcount % prime2) !== 0) step = 3 * prime2;\r\n\t\t\telse {\r\n\t\t\t\tif ((lengthcount % prime3) !== 0) step = 3 * prime3;\r\n\t\t\t\telse step = 3 * prime4;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\ti = 0;\r\n\t\twhile (i < samplepixels) {\r\n\r\n\t\t\tb = (p[pix + 0] & 0xff) << netbiasshift;\r\n\t\t\tg = (p[pix + 1] & 0xff) << netbiasshift;\r\n\t\t\tr = (p[pix + 2] & 0xff) << netbiasshift;\r\n\t\t\tj = contest(b, g, r);\r\n\r\n\t\t\taltersingle(alpha, j, b, g, r);\r\n\t\t\tif (rad !== 0) alterneigh(rad, j, b, g, r); /* alter neighbours */\r\n\r\n\t\t\tpix += step;\r\n\t\t\tif (pix >= lim) pix -= lengthcount;\r\n\r\n\t\t\ti++;\r\n\r\n\t\t\tif (delta === 0) delta = 1;\r\n\r\n\t\t\tif (i % delta === 0) {\r\n\t\t\t\talpha -= alpha / alphadec;\r\n\t\t\t\tradius -= radius / radiusdec;\r\n\t\t\t\trad = radius >> radiusbiasshift;\r\n\r\n\t\t\t\tif (rad <= 1) rad = 0;\r\n\r\n\t\t\t\tfor (j = 0; j < rad; j++) radpower[j] = alpha * (((rad * rad - j * j) * radbias) / (rad * rad));\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\t/*\r\n\t ** Search for BGR values 0..255 (after net is unbiased) and return colour\r\n\t * index\r\n\t * ----------------------------------------------------------------------------\r\n\t */\r\n\r\n\tvar map = exports.map = function map(b, g, r) {\r\n\r\n\t\tvar i;\r\n\t\tvar j;\r\n\t\tvar dist;\r\n\t\tvar a;\r\n\t\tvar bestd;\r\n\t\tvar p;\r\n\t\tvar best;\r\n\r\n\t\tbestd = 1000; /* biggest possible dist is 256*3 */\r\n\t\tbest = -1;\r\n\t\ti = netindex[g]; /* index on g */\r\n\t\tj = i - 1; /* start at netindex[g] and work outwards */\r\n\r\n\t\twhile ((i < netsize) || (j >= 0)) {\r\n\r\n\t\t\tif (i < netsize) {\r\n\t\t\t\tp = network[i];\r\n\t\t\t\tdist = p[1] - g; /* inx key */\r\n\r\n\t\t\t\tif (dist >= bestd) i = netsize; /* stop iter */\r\n\r\n\t\t\t\telse {\r\n\r\n\t\t\t\t\ti++;\r\n\t\t\t\t\tif (dist < 0) dist = -dist;\r\n\t\t\t\t\ta = p[0] - b;\r\n\t\t\t\t\tif (a < 0) a = -a;\r\n\t\t\t\t\tdist += a;\r\n\r\n\t\t\t\t\tif (dist < bestd) {\r\n\t\t\t\t\t\ta = p[2] - r;\r\n\t\t\t\t\t\tif (a < 0) a = -a;\r\n\t\t\t\t\t\tdist += a;\r\n\r\n\t\t\t\t\t\tif (dist < bestd) {\r\n\t\t\t\t\t\t\tbestd = dist;\r\n\t\t\t\t\t\t\tbest = p[3];\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (j >= 0) {\r\n\r\n\t\t\t\tp = network[j];\r\n\t\t\t\tdist = g - p[1]; /* inx key - reverse dif */\r\n\r\n\t\t\t\tif (dist >= bestd) j = -1; /* stop iter */\r\n\r\n\t\t\t\telse {\r\n\r\n\t\t\t\t\tj--;\r\n\t\t\t\t\tif (dist < 0) dist = -dist;\r\n\t\t\t\t\ta = p[0] - b;\r\n\t\t\t\t\tif (a < 0) a = -a;\r\n\t\t\t\t\tdist += a;\r\n\r\n\t\t\t\t\tif (dist < bestd) {\r\n\t\t\t\t\t\ta = p[2] - r;\r\n\t\t\t\t\t\tif (a < 0) a = -a;\r\n\t\t\t\t\t\tdist += a;\r\n\t\t\t\t\t\tif (dist < bestd) {\r\n\t\t\t\t\t\t\tbestd = dist;\r\n\t\t\t\t\t\t\tbest = p[3];\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn (best);\r\n\t};\r\n\r\n\tvar process = exports.process = function process() {\r\n\t\tlearn();\r\n\t\tunbiasnet();\r\n\t\tinxbuild();\r\n\t\treturn colorMap();\r\n\t};\r\n\r\n\t/*\r\n\t * Unbias network to give byte values 0..255 and record position i to prepare\r\n\t * for sort\r\n\t * -----------------------------------------------------------------------------------\r\n\t */\r\n\r\n\tvar unbiasnet = function unbiasnet() {\r\n\r\n\t\tvar i;\r\n\t\tvar j;\r\n\r\n\t\tfor (i = 0; i < netsize; i++) {\r\n\t\t\tnetwork[i][0] >>= netbiasshift;\r\n\t\t\tnetwork[i][1] >>= netbiasshift;\r\n\t\t\tnetwork[i][2] >>= netbiasshift;\r\n\t\t\tnetwork[i][3] = i; /* record colour no */\r\n\t\t}\r\n\t};\r\n\r\n\t/*\r\n\t * Move adjacent neurons by precomputed alpha*(1-((i-j)^2/[r]^2)) in\r\n\t * radpower[|i-j|]\r\n\t * ---------------------------------------------------------------------------------\r\n\t */\r\n\r\n\tvar alterneigh = function alterneigh(rad, i, b, g, r) {\r\n\r\n\t\tvar j;\r\n\t\tvar k;\r\n\t\tvar lo;\r\n\t\tvar hi;\r\n\t\tvar a;\r\n\t\tvar m;\r\n\t\tvar p;\r\n\r\n\t\tlo = i - rad;\r\n\t\tif (lo < -1) lo = -1;\r\n\r\n\t\thi = i + rad;\r\n\t\tif (hi > netsize) hi = netsize;\r\n\r\n\t\tj = i + 1;\r\n\t\tk = i - 1;\r\n\t\tm = 1;\r\n\r\n\t\twhile ((j < hi) || (k > lo)) {\r\n\t\t\ta = radpower[m++];\r\n\r\n\t\t\tif (j < hi) {\r\n\t\t\t\tp = network[j++];\r\n\r\n\t\t\t\ttry {\r\n\t\t\t\t\tp[0] -= (a * (p[0] - b)) / alpharadbias;\r\n\t\t\t\t\tp[1] -= (a * (p[1] - g)) / alpharadbias;\r\n\t\t\t\t\tp[2] -= (a * (p[2] - r)) / alpharadbias;\r\n\t\t\t\t} catch (e) {} // prevents 1.3 miscompilation\r\n\t\t\t}\r\n\r\n\t\t\tif (k > lo) {\r\n\t\t\t\tp = network[k--];\r\n\r\n\t\t\t\ttry {\r\n\t\t\t\t\tp[0] -= (a * (p[0] - b)) / alpharadbias;\r\n\t\t\t\t\tp[1] -= (a * (p[1] - g)) / alpharadbias;\r\n\t\t\t\t\tp[2] -= (a * (p[2] - r)) / alpharadbias;\r\n\t\t\t\t} catch (e) {}\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\t/*\r\n\t * Move neuron i towards biased (b,g,r) by factor alpha\r\n\t * ----------------------------------------------------\r\n\t */\r\n\r\n\tvar altersingle = function altersingle(alpha, i, b, g, r) {\r\n\r\n\t\t/* alter hit neuron */\r\n\t\tvar n = network[i];\r\n\t\tn[0] -= (alpha * (n[0] - b)) / initalpha;\r\n\t\tn[1] -= (alpha * (n[1] - g)) / initalpha;\r\n\t\tn[2] -= (alpha * (n[2] - r)) / initalpha;\r\n\t};\r\n\r\n\t/*\r\n\t * Search for biased BGR values ----------------------------\r\n\t */\r\n\r\n\tvar contest = function contest(b, g, r) {\r\n\r\n\t\t/* finds closest neuron (min dist) and updates freq */\r\n\t\t/* finds best neuron (min dist-bias) and returns position */\r\n\t\t/* for frequently chosen neurons, freq[i] is high and bias[i] is negative */\r\n\t\t/* bias[i] = gamma*((1/netsize)-freq[i]) */\r\n\r\n\t\tvar i;\r\n\t\tvar dist;\r\n\t\tvar a;\r\n\t\tvar biasdist;\r\n\t\tvar betafreq;\r\n\t\tvar bestpos;\r\n\t\tvar bestbiaspos;\r\n\t\tvar bestd;\r\n\t\tvar bestbiasd;\r\n\t\tvar n;\r\n\r\n\t\tbestd = ~ (1 << 31);\r\n\t\tbestbiasd = bestd;\r\n\t\tbestpos = -1;\r\n\t\tbestbiaspos = bestpos;\r\n\r\n\t\tfor (i = 0; i < netsize; i++) {\r\n\t\t\tn = network[i];\r\n\t\t\tdist = n[0] - b;\r\n\t\t\tif (dist < 0) dist = -dist;\r\n\t\t\ta = n[1] - g;\r\n\t\t\tif (a < 0) a = -a;\r\n\t\t\tdist += a;\r\n\t\t\ta = n[2] - r;\r\n\t\t\tif (a < 0) a = -a;\r\n\t\t\tdist += a;\r\n\r\n\t\t\tif (dist < bestd) {\r\n\t\t\t\tbestd = dist;\r\n\t\t\t\tbestpos = i;\r\n\t\t\t}\r\n\r\n\t\t\tbiasdist = dist - ((bias[i]) >> (intbiasshift - netbiasshift));\r\n\r\n\t\t\tif (biasdist < bestbiasd) {\r\n\t\t\t\tbestbiasd = biasdist;\r\n\t\t\t\tbestbiaspos = i;\r\n\t\t\t}\r\n\r\n\t\t\tbetafreq = (freq[i] >> betashift);\r\n\t\t\tfreq[i] -= betafreq;\r\n\t\t\tbias[i] += (betafreq << gammashift);\r\n\t\t}\r\n\r\n\t\tfreq[bestpos] += beta;\r\n\t\tbias[bestpos] -= betagamma;\r\n\t\treturn (bestbiaspos);\r\n\t};\r\n\r\n\tNeuQuant.apply(this, arguments);\r\n\treturn exports;\r\n};\r\n'},function(t,r,n){n(0)(n(10))},function(t,r){t.exports='/**\r\n * This class lets you encode animated GIF files\r\n * Base class :  http://www.java2s.com/Code/Java/2D-Graphics-GUI/AnimatedGifEncoder.htm\r\n * @author Kevin Weiner (original Java version - kweiner@fmsware.com)\r\n * @author Thibault Imbert (AS3 version - bytearray.org)\r\n * @author Kevin Kwok (JavaScript version - https://github.com/antimatter15/jsgif)\r\n * @version 0.1 AS3 implementation\r\n */\r\n\r\nGIFEncoder = function() {\r\n\r\n\tfor (var i = 0, chr = {}; i < 256; i++)\r\n\t\tchr[i] = String.fromCharCode(i);\r\n\r\n\tfunction ByteArray() {\r\n\t\tthis.bin = [];\r\n\t}\r\n\r\n\tByteArray.prototype.getData = function() {\r\n\t\tfor (var v = \'\', l = this.bin.length, i = 0; i < l; i++)\r\n\t\t\tv += chr[this.bin[i]];\r\n\t\treturn v;\r\n\t};\r\n\r\n\tByteArray.prototype.writeByte = function(val) {\r\n\t\tthis.bin.push(val);\r\n\t};\r\n\r\n\tByteArray.prototype.writeUTFBytes = function(string) {\r\n\t\tfor (var l = string.length, i = 0; i < l; i++)\r\n\t\t\tthis.writeByte(string.charCodeAt(i));\r\n\t};\r\n\r\n\tByteArray.prototype.writeBytes = function(array, offset, length) {\r\n\t\tfor (var l = length || array.length, i = offset || 0; i < l; i++)\r\n\t\t\tthis.writeByte(array[i]);\r\n\t};\r\n\r\n\tvar exports = {};\r\n\tvar width; // image size\r\n\tvar height;\r\n\tvar transparent = null; // transparent color if given\r\n\tvar transIndex; // transparent index in color table\r\n\tvar repeat = -1; // no repeat\r\n\tvar delay = 0; // frame delay (hundredths)\r\n\tvar started = false; // ready to output frames\r\n\tvar out;\r\n\tvar image; // current frame\r\n\tvar pixels; // BGR byte array from frame\r\n\tvar indexedPixels; // converted frame indexed to palette\r\n\tvar colorDepth; // number of bit planes\r\n\tvar colorTab; // RGB palette\r\n\tvar usedEntry = []; // active palette entries\r\n\tvar palSize = 7; // color table size (bits-1)\r\n\tvar dispose = -1; // disposal code (-1 = use default)\r\n\tvar closeStream = false; // close stream when finished\r\n\tvar firstFrame = true;\r\n\tvar sizeSet = false; // if false, get size from first frame\r\n\tvar sample = 10; // default sample interval for quantizer\r\n\tvar comment = "Generated by jsgif (https://github.com/antimatter15/jsgif/)"; // default comment for generated gif\r\n\r\n\t/**\r\n\t * Sets the delay time between each frame, or changes it for subsequent frames\r\n\t * (applies to last frame added)\r\n\t * int delay time in milliseconds\r\n\t * @param ms\r\n\t */\r\n\r\n\tvar setDelay = exports.setDelay = function setDelay(ms) {\r\n\t\tdelay = Math.round(ms / 10);\r\n\t};\r\n\r\n\t/**\r\n\t * Sets the GIF frame disposal code for the last added frame and any\r\n\t *\r\n\t * subsequent frames. Default is 0 if no transparent color has been set,\r\n\t * otherwise 2.\r\n\t * @param code\r\n\t * int disposal code.\r\n\t */\r\n\r\n\tvar setDispose = exports.setDispose = function setDispose(code) {\r\n\t\tif (code >= 0) dispose = code;\r\n\t};\r\n\r\n\t/**\r\n\t * Sets the number of times the set of GIF frames should be played. Default is\r\n\t * 1; 0 means play indefinitely. Must be invoked before the first image is\r\n\t * added.\r\n\t *\r\n\t * @param iter\r\n\t * int number of iterations.\r\n\t * @return\r\n\t */\r\n\r\n\tvar setRepeat = exports.setRepeat = function setRepeat(iter) {\r\n\t\tif (iter >= 0) repeat = iter;\r\n\t};\r\n\r\n\t/**\r\n\t * Sets the transparent color for the last added frame and any subsequent\r\n\t * frames. Since all colors are subject to modification in the quantization\r\n\t * process, the color in the final palette for each frame closest to the given\r\n\t * color becomes the transparent color for that frame. May be set to null to\r\n\t * indicate no transparent color.\r\n\t * @param\r\n\t * Color to be treated as transparent on display.\r\n\t */\r\n\r\n\tvar setTransparent = exports.setTransparent = function setTransparent(c) {\r\n\t\ttransparent = c;\r\n\t};\r\n\r\n\r\n\t/**\r\n\t * Sets the comment for the block comment\r\n\t * @param\r\n\t * string to be insterted as comment\r\n\t */\r\n\r\n\tvar setComment = exports.setComment = function setComment(c) {\r\n\t\tcomment = c;\r\n\t};\r\n\r\n\r\n\r\n\t/**\r\n\t * The addFrame method takes an incoming BitmapData object to create each frames\r\n\t * @param\r\n\t * BitmapData object to be treated as a GIF\'s frame\r\n\t */\r\n\r\n\tvar addFrame = exports.addFrame = function addFrame(im, is_imageData) {\r\n\r\n\t\tif ((im === null) || !started || out === null) {\r\n\t\t\tthrow new Error("Please call start method before calling addFrame");\r\n\t\t}\r\n\r\n\t\tvar ok = true;\r\n\r\n\t\ttry {\r\n\t\t\tif (!is_imageData) {\r\n\t\t\t\timage = im.getImageData(0, 0, im.canvas.width, im.canvas.height).data;\r\n\t\t\t\tif (!sizeSet) setSize(im.canvas.width, im.canvas.height);\r\n\t\t\t} else {\r\n\t\t\t\tif(im instanceof ImageData) {\r\n\t\t\t\t\timage = im.data;\r\n\t\t\t\t\tif(!sizeset || width!=im.width || height!=im.height) {\r\n\t\t\t\t\t\tsetSize(im.width,im.height);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if(im instanceof Uint8ClampedArray) {\r\n\t\t\t\t\tif(im.length==(width*height*4)) {\r\n\t\t\t\t\t\timage=im;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tconsole.log("Please set the correct size: ImageData length mismatch");\r\n\t\t\t\t\t\tok=false;\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tconsole.log("Please provide correct input");\r\n\t\t\t\t\tok=false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tgetImagePixels(); // convert to correct format if necessary\r\n\t\t\tanalyzePixels(); // build color table & map pixels\r\n\r\n\t\t\tif (firstFrame) {\r\n\t\t\t\twriteLSD(); // logical screen descriptior\r\n\t\t\t\twritePalette(); // global color table\r\n\t\t\t\tif (repeat >= 0) {\r\n\t\t\t\t\t// use NS app extension to indicate reps\r\n\t\t\t\t\twriteNetscapeExt();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\twriteGraphicCtrlExt(); // write graphic control extension\r\n\t\t\tif (comment !== \'\') {\r\n\t\t\t\twriteCommentExt(); // write comment extension\r\n\t\t\t}\r\n\t\t\twriteImageDesc(); // image descriptor\r\n\t\t\tif (!firstFrame) writePalette(); // local color table\r\n\t\t\twritePixels(); // encode and write pixel data\r\n\t\t\tfirstFrame = false;\r\n\t\t} catch (e) {\r\n\t\t\tok = false;\r\n\t\t}\r\n\r\n\t\treturn ok;\r\n\t};\r\n\t\r\n\t/**\r\n\t* @description: Downloads the encoded gif with the given name\r\n\t* No need of any conversion from the stream data (out) to base64\r\n\t* Solves the issue of large file sizes when there are more frames\r\n\t* and does not involve in creation of any temporary data in the process\r\n\t* so no wastage of memory, and speeds up the process of downloading\r\n\t* to just calling this function.\r\n\t* @parameter {String} filename filename used for downloading the gif\r\n\t*/\r\n\t\r\n\tvar download = exports.download = function download(filename) {\r\n\t\tif(out===null || closeStream==false) {\r\n\t\t\tconsole.log("Please call start method and add frames and call finish method before calling download"); \r\n\t\t} else {\r\n\t\t\tfilename= filename !== undefined ? ( filename.endsWith(".gif")? filename: filename+".gif" ): "download.gif";\r\n\t\t\tvar templink = document.createElement("a");\r\n\t\t\ttemplink.download=filename;\r\n\t\t\ttemplink.href= URL.createObjectURL(new Blob([new Uint8Array(out.bin)], {type : "image/gif" } ));\r\n\t\t\ttemplink.click();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Adds final trailer to the GIF stream, if you don\'t call the finish method\r\n\t * the GIF stream will not be valid.\r\n\t */\r\n\r\n\tvar finish = exports.finish = function finish() {\r\n\r\n\t\tif (!started) return false;\r\n\r\n\t\tvar ok = true;\r\n\t\tstarted = false;\r\n\r\n\t\ttry {\r\n\t\t\tout.writeByte(0x3b); // gif trailer\r\n\t\t\tcloseStream=true;\r\n\t\t} catch (e) {\r\n\t\t\tok = false;\r\n\t\t}\r\n\r\n\t\treturn ok;\r\n\t};\r\n\r\n\t/**\r\n\t * Resets some members so that a new stream can be started.\r\n\t * This method is actually called by the start method\r\n\t */\r\n\r\n\tvar reset = function reset() {\r\n\r\n\t\t// reset for subsequent use\r\n\t\ttransIndex = 0;\r\n\t\timage = null;\r\n\t\tpixels = null;\r\n\t\tindexedPixels = null;\r\n\t\tcolorTab = null;\r\n\t\tcloseStream = false;\r\n\t\tfirstFrame = true;\r\n\t};\r\n\r\n\t/**\r\n\t * * Sets frame rate in frames per second. Equivalent to\r\n\t * <code>setDelay(1000/fps)</code>.\r\n\t * @param fps\r\n\t * float frame rate (frames per second)\r\n\t */\r\n\r\n\tvar setFrameRate = exports.setFrameRate = function setFrameRate(fps) {\r\n\t\tif (fps != 0xf) delay = Math.round(100 / fps);\r\n\t};\r\n\r\n\t/**\r\n\t * Sets quality of color quantization (conversion of images to the maximum 256\r\n\t * colors allowed by the GIF specification). Lower values (minimum = 1)\r\n\t * produce better colors, but slow processing significantly. 10 is the\r\n\t * default, and produces good color mapping at reasonable speeds. Values\r\n\t * greater than 20 do not yield significant improvements in speed.\r\n\t * @param quality\r\n\t * int greater than 0.\r\n\t * @return\r\n\t */\r\n\r\n\tvar setQuality = exports.setQuality = function setQuality(quality) {\r\n\t\tif (quality < 1) quality = 1;\r\n\t\tsample = quality;\r\n\t};\r\n\r\n\t/**\r\n\t * Sets the GIF frame size. The default size is the size of the first frame\r\n\t * added if this method is not invoked.\r\n\t * @param w\r\n\t * int frame width.\r\n\t * @param h\r\n\t * int frame width.\r\n\t */\r\n\r\n\tvar setSize = exports.setSize = function setSize(w, h) {\r\n\r\n\t\tif (started && !firstFrame) return;\r\n\t\twidth = w;\r\n\t\theight = h;\r\n\t\tif (width < 1) width = 320;\r\n\t\tif (height < 1) height = 240;\r\n\t\tsizeSet = true;\r\n\t};\r\n\r\n\t/**\r\n\t * Initiates GIF file creation on the given stream.\r\n\t * @param os\r\n\t * OutputStream on which GIF images are written.\r\n\t * @return false if initial write failed.\r\n\t */\r\n\r\n\tvar start = exports.start = function start() {\r\n\r\n\t\treset();\r\n\t\tvar ok = true;\r\n\t\tcloseStream = false;\r\n\t\tout = new ByteArray();\r\n\t\ttry {\r\n\t\t\tout.writeUTFBytes("GIF89a"); // header\r\n\t\t} catch (e) {\r\n\t\t\tok = false;\r\n\t\t}\r\n\r\n\t\treturn started = ok;\r\n\t};\r\n\r\n\tvar cont = exports.cont = function cont() {\r\n\r\n\t\treset();\r\n\t\tvar ok = true;\r\n\t\tcloseStream = false;\r\n\t\tout = new ByteArray();\r\n\r\n\t\treturn started = ok;\r\n\t};\r\n\r\n\t/**\r\n\t * Analyzes image colors and creates color map.\r\n\t */\r\n\r\n\tvar analyzePixels = function analyzePixels() {\r\n\r\n\t\tvar len = pixels.length;\r\n\t\tvar nPix = len / 3;\r\n\t\tindexedPixels = [];\r\n\t\tvar nq = new NeuQuant(pixels, len, sample);\r\n\r\n\t\t// initialize quantizer\r\n\t\tcolorTab = nq.process(); // create reduced palette\r\n\r\n\t\t// map image pixels to new palette\r\n\t\tvar k = 0;\r\n\t\tfor (var j = 0; j < nPix; j++) {\r\n\t\t\tvar index = nq.map(pixels[k++] & 0xff, pixels[k++] & 0xff, pixels[k++] & 0xff);\r\n\t\t\tusedEntry[index] = true;\r\n\t\t\tindexedPixels[j] = index;\r\n\t\t}\r\n\r\n\t\tpixels = null;\r\n\t\tcolorDepth = 8;\r\n\t\tpalSize = 7;\r\n\r\n\t\t// get closest match to transparent color if specified\r\n\t\tif (transparent !== null) {\r\n\t\t\ttransIndex = findClosest(transparent);\r\n\t\t}\r\n\t};\r\n\r\n\t/**\r\n\t * Returns index of palette color closest to c\r\n\t */\r\n\r\n\tvar findClosest = function findClosest(c) {\r\n\r\n\t\tif (colorTab === null) return -1;\r\n\t\tvar r = (c & 0xFF0000) >> 16;\r\n\t\tvar g = (c & 0x00FF00) >> 8;\r\n\t\tvar b = (c & 0x0000FF);\r\n\t\tvar minpos = 0;\r\n\t\tvar dmin = 256 * 256 * 256;\r\n\t\tvar len = colorTab.length;\r\n\r\n\t\tfor (var i = 0; i < len;) {\r\n\t\t\tvar dr = r - (colorTab[i++] & 0xff);\r\n\t\t\tvar dg = g - (colorTab[i++] & 0xff);\r\n\t\t\tvar db = b - (colorTab[i] & 0xff);\r\n\t\t\tvar d = dr * dr + dg * dg + db * db;\r\n\t\t\tvar index = i / 3;\r\n\t\t\tif (usedEntry[index] && (d < dmin)) {\r\n\t\t\t\tdmin = d;\r\n\t\t\t\tminpos = index;\r\n\t\t\t}\r\n\t\t\ti++;\r\n\t\t}\r\n\t\treturn minpos;\r\n\t};\r\n\r\n\t/**\r\n\t * Extracts image pixels into byte array "pixels\r\n\t */\r\n\r\n\tvar getImagePixels = function getImagePixels() {\r\n\t\tvar w = width;\r\n\t\tvar h = height;\r\n\t\tpixels = [];\r\n\t\tvar data = image;\r\n\t\tvar count = 0;\r\n\r\n\t\tfor (var i = 0; i < h; i++) {\r\n\r\n\t\t\tfor (var j = 0; j < w; j++) {\r\n\r\n\t\t\t\tvar b = (i * w * 4) + j * 4;\r\n\t\t\t\tpixels[count++] = data[b];\r\n\t\t\t\tpixels[count++] = data[b + 1];\r\n\t\t\t\tpixels[count++] = data[b + 2];\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\t};\r\n\r\n\t/**\r\n\t * Writes Graphic Control Extension\r\n\t */\r\n\r\n\tvar writeGraphicCtrlExt = function writeGraphicCtrlExt() {\r\n\t\tout.writeByte(0x21); // extension introducer\r\n\t\tout.writeByte(0xf9); // GCE label\r\n\t\tout.writeByte(4); // data block size\r\n\t\tvar transp;\r\n\t\tvar disp;\r\n\t\tif (transparent === null) {\r\n\t\t\ttransp = 0;\r\n\t\t\tdisp = 0; // dispose = no action\r\n\t\t} else {\r\n\t\t\ttransp = 1;\r\n\t\t\tdisp = 2; // force clear if using transparent color\r\n\t\t}\r\n\t\tif (dispose >= 0) {\r\n\t\t\tdisp = dispose & 7; // user override\r\n\t\t}\r\n\t\tdisp <<= 2;\r\n\t\t// packed fields\r\n\t\tout.writeByte(0 | // 1:3 reserved\r\n\t\t\tdisp | // 4:6 disposal\r\n\t\t\t0 | // 7 user input - 0 = none\r\n\t\t\ttransp); // 8 transparency flag\r\n\r\n\t\tWriteShort(delay); // delay x 1/100 sec\r\n\t\tout.writeByte(transIndex); // transparent color index\r\n\t\tout.writeByte(0); // block terminator\r\n\t};\r\n\r\n\t/**\r\n\t * Writes Comment Extention\r\n\t */\r\n\r\n\tvar writeCommentExt = function writeCommentExt() {\r\n\t\tout.writeByte(0x21); // extension introducer\r\n\t\tout.writeByte(0xfe); // comment label\r\n\t\tout.writeByte(comment.length); // Block Size (s)\r\n\t\tout.writeUTFBytes(comment);\r\n\t\tout.writeByte(0); // block terminator\r\n\t};\r\n\r\n\r\n\t/**\r\n\t * Writes Image Descriptor\r\n\t */\r\n\r\n\tvar writeImageDesc = function writeImageDesc() {\r\n\r\n\t\tout.writeByte(0x2c); // image separator\r\n\t\tWriteShort(0); // image position x,y = 0,0\r\n\t\tWriteShort(0);\r\n\t\tWriteShort(width); // image size\r\n\t\tWriteShort(height);\r\n\r\n\t\t// packed fields\r\n\t\tif (firstFrame) {\r\n\t\t\t// no LCT - GCT is used for first (or only) frame\r\n\t\t\tout.writeByte(0);\r\n\t\t} else {\r\n\t\t\t// specify normal LCT\r\n\t\t\tout.writeByte(0x80 | // 1 local color table 1=yes\r\n\t\t\t\t0 | // 2 interlace - 0=no\r\n\t\t\t\t0 | // 3 sorted - 0=no\r\n\t\t\t\t0 | // 4-5 reserved\r\n\t\t\t\tpalSize); // 6-8 size of color table\r\n\t\t}\r\n\t};\r\n\r\n\t/**\r\n\t * Writes Logical Screen Descriptor\r\n\t */\r\n\r\n\tvar writeLSD = function writeLSD() {\r\n\r\n\t\t// logical screen size\r\n\t\tWriteShort(width);\r\n\t\tWriteShort(height);\r\n\t\t// packed fields\r\n\t\tout.writeByte((0x80 | // 1 : global color table flag = 1 (gct used)\r\n\t\t\t0x70 | // 2-4 : color resolution = 7\r\n\t\t\t0x00 | // 5 : gct sort flag = 0\r\n\t\t\tpalSize)); // 6-8 : gct size\r\n\r\n\t\tout.writeByte(0); // background color index\r\n\t\tout.writeByte(0); // pixel aspect ratio - assume 1:1\r\n\t};\r\n\r\n\t/**\r\n\t * Writes Netscape application extension to define repeat count.\r\n\t */\r\n\r\n\tvar writeNetscapeExt = function writeNetscapeExt() {\r\n\t\tout.writeByte(0x21); // extension introducer\r\n\t\tout.writeByte(0xff); // app extension label\r\n\t\tout.writeByte(11); // block size\r\n\t\tout.writeUTFBytes("NETSCAPE" + "2.0"); // app id + auth code\r\n\t\tout.writeByte(3); // sub-block size\r\n\t\tout.writeByte(1); // loop sub-block id\r\n\t\tWriteShort(repeat); // loop count (extra iterations, 0=repeat forever)\r\n\t\tout.writeByte(0); // block terminator\r\n\t};\r\n\r\n\t/**\r\n\t * Writes color table\r\n\t */\r\n\r\n\tvar writePalette = function writePalette() {\r\n\t\tout.writeBytes(colorTab);\r\n\t\tvar n = (3 * 256) - colorTab.length;\r\n\t\tfor (var i = 0; i < n; i++) out.writeByte(0);\r\n\t};\r\n\r\n\tvar WriteShort = function WriteShort(pValue) {\r\n\t\tout.writeByte(pValue & 0xFF);\r\n\t\tout.writeByte((pValue >> 8) & 0xFF);\r\n\t};\r\n\r\n\t/**\r\n\t * Encodes and writes pixel data\r\n\t */\r\n\r\n\tvar writePixels = function writePixels() {\r\n\t\tvar myencoder = new LZWEncoder(width, height, indexedPixels, colorDepth);\r\n\t\tmyencoder.encode(out);\r\n\t};\r\n\r\n\t/**\r\n\t * Retrieves the GIF stream\r\n\t */\r\n\r\n\tvar stream = exports.stream = function stream() {\r\n\t\treturn out;\r\n\t};\r\n\r\n\tvar setProperties = exports.setProperties = function setProperties(has_start, is_first) {\r\n\t\tstarted = has_start;\r\n\t\tfirstFrame = is_first;\r\n\t};\r\n\r\n\treturn exports;\r\n\r\n};\r\n'},function(t,r,n){n(0)(n(12))},function(t,r){t.exports='function encode64(input) {\n\tvar output = "", i = 0, l = input.length,\n\tkey = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", \n\tchr1, chr2, chr3, enc1, enc2, enc3, enc4;\n\twhile (i < l) {\n\t\tchr1 = input.charCodeAt(i++);\n\t\tchr2 = input.charCodeAt(i++);\n\t\tchr3 = input.charCodeAt(i++);\n\t\tenc1 = chr1 >> 2;\n\t\tenc2 = ((chr1 & 3) << 4) | (chr2 >> 4);\n\t\tenc3 = ((chr2 & 15) << 2) | (chr3 >> 6);\n\t\tenc4 = chr3 & 63;\n\t\tif (isNaN(chr2)) enc3 = enc4 = 64;\n\t\telse if (isNaN(chr3)) enc4 = 64;\n\t\toutput = output + key.charAt(enc1) + key.charAt(enc2) + key.charAt(enc3) + key.charAt(enc4);\n\t}\n\treturn output;\n}\n'},function(t,r,n){"use strict";n.r(r);n(3),n(4),n(5),n(7),n(9),n(11);const e=document.querySelector(".tools__pen"),a=document.querySelector(".tools__paint-bucket"),i=document.querySelector(".tools__paint-all-pixels-of-the-same-color"),o=document.querySelector(".tools__eraser"),s=document.querySelector(".tools__stroke"),l=document.querySelector(".tools__color-picker"),c=document.querySelector(".canvas-1"),d=c.getContext("2d"),f=document.querySelector(".tools__primary-color-input"),u=document.querySelector(".tools__secondary-color-input"),p=document.querySelector(".tools__primary-color-button"),m=document.querySelector(".tools__secondary-color-button"),h=document.querySelector(".tools__swap-colors-button"),v=document.querySelector(".tools__btn-1"),b=document.querySelector(".tools__btn-2"),g=document.querySelector(".tools__btn-3"),x=document.querySelector(".tools__btn-4"),y=document.querySelector(".frame"),w=document.querySelector(".frames"),_=document.querySelector(".canvas-wrapper"),S=document.querySelector(".frames__create-new-frame-button"),k=document.querySelector(".frames__delete-frame-button"),C=document.querySelector(".output__final-gif"),z=document.querySelector(".output__refresh-button"),E=document.querySelector(".output__download-button"),F=document.querySelector(".output__fps-input"),L=document.querySelector(".output__fps-figure");var j=n(1),q=n.n(j),B=n(2),A=n.n(B);c.number=1,f.value="#000000",u.value="#ffffff",p.addEventListener("click",()=>f.click()),m.addEventListener("click",()=>u.click()),f.addEventListener("change",t=>{I.primaryColor=t.target.value,p.style.background=t.target.value}),u.addEventListener("change",t=>{I.secondaryColor=t.target.value,m.style.background=t.target.value}),h.addEventListener("click",(function(){let t=f.value;f.value=u.value,I.primaryColor=f.value,p.style.background=f.value,u.value=t,I.secondaryColor=t,m.style.background=t,t=void 0}));const I={tool:"pen",isDrawing:!1,matrixCoefficient:16,xStart:void 0,yStart:void 0,primaryColor:"#000000",secondaryColor:"#ffffff",activeCanvas:c,activeCanvasContext:d,activeFrameNumber:1,fpsRate:500,pixelSize:1,drawBresenhamLine(t,r,n,e,a,i){const o=i;function s(r,n){t.fillRect(r,n,o*I.pixelSize,o*I.pixelSize)}((t,r,n,e)=>{let a=t,i=r;const l=n,c=e;if(a===l&&i===c)return void s(a,i);const d=l-a,f=d<0?-1:1,u=c-i,p=u<0?-1:1;if(Math.abs(u)<Math.abs(d)){const t=u/d,r=i-t*a;for(;a!==l;)s(a,parseInt(Math.round(t*a+r),10)),a+=f*o}else{const t=d/u,r=a-t*i;for(;i!==c;)s(parseInt(Math.round(t*i+r),10),i),i+=p*o}s(l,c)})(r,n,e,a)},clearBresenhamLine(t,r,n,e,a,i){const o=i;function s(r,n){r/I.matrixCoefficient%2==n/I.matrixCoefficient%2?t.fillStyle="rgb(76, 76, 76)":t.fillStyle="rgb(85, 85, 85)",t.fillRect(r,n,o,o)}((t,r,n,e)=>{let a=t,i=r;const l=n,c=e;if(a===l&&i===c)return void s(a,i);const d=l-a,f=d<0?-1:1,u=c-i,p=u<0?-1:1;if(Math.abs(u)<Math.abs(d)){const t=u/d,r=i-t*a;for(;a!==l;)s(a,parseInt(Math.round(t*a+r),10)),a+=f*o}else{const t=d/u,r=a-t*i;for(;i!==c;)s(parseInt(Math.round(t*i+r),10),i),i+=p*o}s(l,c)})(r,n,e,a)},fillBucket(t,r,n,e){0===t.button?e.fillStyle=I.primaryColor:e.fillStyle=I.secondaryColor;const a=r,i=e.getImageData(t.offsetX,t.offsetY,1,1),o=JSON.stringify(Array.from(i.data)),s=e.getImageData(0,0,n.width,n.height).data;function l(t,r){if(t>=0&&t<n.width&&r>=0&&r<n.height){const e=4*(r*n.width+t),a=e+1,i=a+1,o=i+1;return[s[e],s[a],s[i],s[o]]}return!1}const c=[],d={};function f(t,r){const n=l(t,r-a),i=l(t-a,r),s=l(t+a,r),f=l(t,r+a);if(n&&(JSON.stringify(n)===o||"[85,85,85,255]"===JSON.stringify(n)||"[76,76,76,255]"===JSON.stringify(n))){const n=`[${t},${r-a}]`;d[n]||(c.push(n),d[n]=!0)}if(i&&(JSON.stringify(i)===o||"[85,85,85,255]"===JSON.stringify(i)||"[76,76,76,255]"===JSON.stringify(i))){const n=`[${t-a},${r}]`;d[n]||(c.push(n),d[n]=!0)}if(s&&(JSON.stringify(s)===o||"[85,85,85,255]"===JSON.stringify(s)||"[76,76,76,255]"===JSON.stringify(s))){const n=`[${t+a},${r}]`;d[n]||(c.push(n),d[n]=!0)}if(f&&(JSON.stringify(f)===o||"[85,85,85,255]"===JSON.stringify(f)||"[76,76,76,255]"===JSON.stringify(f))){const n=`[${t},${r+a}]`;d[n]||(c.push(n),d[n]=!0)}e.fillRect(t,r,a,a)}!function(t,r){for(c.push(JSON.stringify([t,r]));c.length;){const t=JSON.parse(c.pop());f(t[0],t[1])}}(t.offsetX-t.offsetX%a,t.offsetY-t.offsetY%a)},paintAllPixelsOfTheSameColor(t,r,n,e){0===t.button?e.fillStyle=I.primaryColor:e.fillStyle=I.secondaryColor;const a=r,i=e.getImageData(t.offsetX,t.offsetY,1,1),o=Array.from(i.data),s=e.getImageData(0,0,n.width,n.height).data;for(let t=0;t<s.length;t+=512*a*4)for(let r=t;r<4*(t+512);r+=4*a)o[0]===s[r]&&o[1]===s[r+1]&&o[2]===s[r+2]&&o[3]===s[r+3]&&e.fillRect(r/4%512,Math.floor(r/4/512),a,a)},rgba2hex(t){const r=t.match(/^rgba?[\s+]?\([\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?/i);return r&&4===r.length?`#${`0${parseInt(r[1],10).toString(16)}`.slice(-2)}${`0${parseInt(r[2],10).toString(16)}`.slice(-2)}${`0${parseInt(r[3],10).toString(16)}`.slice(-2)}`:""}};X(d),v.addEventListener("click",()=>{I.pixelSize=1;const t=[v,b,g,x];for(let r=0;r<4;r+=1)t[r].classList.remove("tools__active-pen-size-button");v.classList.add("tools__active-pen-size-button")}),b.addEventListener("click",()=>{I.pixelSize=2;const t=[v,b,g,x];for(let r=0;r<4;r+=1)t[r].classList.remove("tools__active-pen-size-button");b.classList.add("tools__active-pen-size-button")}),g.addEventListener("click",()=>{I.pixelSize=3;const t=[v,b,g,x];for(let r=0;r<4;r+=1)t[r].classList.remove("tools__active-pen-size-button");g.classList.add("tools__active-pen-size-button")}),x.addEventListener("click",()=>{I.pixelSize=4;const t=[v,b,g,x];for(let r=0;r<4;r+=1)t[r].classList.remove("tools__active-pen-size-button");x.classList.add("tools__active-pen-size-button")});const D=[e,a,i,o,s,l];function N(t){const r=t.getContext("2d");t.addEventListener("contextmenu",t=>t.preventDefault()),t.addEventListener("mousedown",t=>{if(I.isDrawing=!0,"pen"===I.tool&&(0===t.button?r.fillStyle=I.primaryColor:r.fillStyle=I.secondaryColor,I.xStart=t.offsetX-t.offsetX%I.matrixCoefficient,I.yStart=t.offsetY-t.offsetY%I.matrixCoefficient,I.drawBresenhamLine(I.activeCanvasContext,I.xStart,I.yStart,I.xStart,I.yStart,I.matrixCoefficient)),"eraser"===I.tool&&(I.xStart=t.offsetX-t.offsetX%I.matrixCoefficient,I.yStart=t.offsetY-t.offsetY%I.matrixCoefficient,I.clearBresenhamLine(I.activeCanvasContext,I.xStart,I.yStart,I.xStart,I.yStart,I.matrixCoefficient)),"paintBucket"===I.tool&&I.fillBucket(t,I.matrixCoefficient,I.activeCanvas,I.activeCanvasContext),"colorPicker"===I.tool){const r=I.activeCanvasContext.getImageData(t.offsetX,t.offsetY,1,1),n=I.rgba2hex(`rgba(${r.data[0]}, ${r.data[1]}, ${r.data[2]}, ${r.data[3]/255})`);0===t.button?I.primaryColor!==n&&(I.primaryColor=n,p.style.background=I.primaryColor,f.value=I.primaryColor):I.secondaryColor!==n&&(I.secondaryColor=n,m.style.background=I.secondaryColor,u.value=I.secondaryColor)}"paintAllPixelsOfTheSameColor"===I.tool&&I.paintAllPixelsOfTheSameColor(t,I.matrixCoefficient,I.activeCanvas,I.activeCanvasContext)}),t.addEventListener("mousemove",t=>{"pen"===I.tool&&I.isDrawing&&(I.drawBresenhamLine(I.activeCanvasContext,I.xStart,I.yStart,t.offsetX-t.offsetX%I.matrixCoefficient,t.offsetY-t.offsetY%I.matrixCoefficient,I.matrixCoefficient),I.xStart=t.offsetX-t.offsetX%I.matrixCoefficient,I.yStart=t.offsetY-t.offsetY%I.matrixCoefficient),"eraser"===I.tool&&I.isDrawing&&(I.clearBresenhamLine(I.activeCanvasContext,I.xStart,I.yStart,t.offsetX-t.offsetX%I.matrixCoefficient,t.offsetY-t.offsetY%I.matrixCoefficient,I.matrixCoefficient),I.xStart=t.offsetX-t.offsetX%I.matrixCoefficient,I.yStart=t.offsetY-t.offsetY%I.matrixCoefficient)}),t.addEventListener("mouseup",()=>{I.isDrawing=!1,O()}),t.addEventListener("mouseout",()=>{I.isDrawing=!1,O()})}e.addEventListener("click",()=>{I.tool="pen";for(let t=0;t<D.length;t+=1)D[t].classList.remove("tools__active-button");e.classList.add("tools__active-button")}),a.addEventListener("click",()=>{I.tool="paintBucket";for(let t=0;t<D.length;t+=1)D[t].classList.remove("tools__active-button");a.classList.add("tools__active-button")}),i.addEventListener("click",()=>{I.tool="paintAllPixelsOfTheSameColor";for(let t=0;t<D.length;t+=1)D[t].classList.remove("tools__active-button");i.classList.add("tools__active-button")}),o.addEventListener("click",()=>{I.tool="eraser";for(let t=0;t<D.length;t+=1)D[t].classList.remove("tools__active-button");o.classList.add("tools__active-button")}),s.addEventListener("click",()=>{I.tool="stroke";for(let t=0;t<D.length;t+=1)D[t].classList.remove("tools__active-button");s.classList.add("tools__active-button")}),l.addEventListener("click",()=>{I.tool="colorPicker";for(let t=0;t<D.length;t+=1)D[t].classList.remove("tools__active-button");l.classList.add("tools__active-button")}),N(c);let P=[c],T=[d];function O(){let t=I.activeCanvas.toDataURL("image/png");document.querySelector(".frames").children[R(I.activeCanvas.number)].children[0].src=t}function G(){for(let t=0;t<P.length;t+=1)P[t].classList.add("hidden")}function M(t){I.activeFrameNumber=t,I.activeCanvas=document.querySelector(`.canvas-${t}`),I.activeCanvasContext=I.activeCanvas.getContext("2d"),G(),I.activeCanvas.classList.remove("hidden");const r=document.querySelector(".frames");for(let t=0;t<r.children.length;t+=1)r.children[t].classList.remove("frames__active-frame");r.children[R(t)].classList.add("frames__active-frame")}function W(t){if(P.length>1){const r=R(t);I.activeFrameNumber===t&&M(r>0?P[r-1].number:P[r+1].number);const n=function(t){const r=R(t),n=P.slice(0,r);n.push(...P.slice(r+1,P.length)),P=n;const e=T.slice(0,r);return e.push(...T.slice(r+1,T.length)),T=e,r}(t);_.removeChild(_.children[n]),w.removeChild(w.children[n])}}function R(t){for(let r=0;r<P.length;r+=1)if(P[r].number===t)return r}function J(){const t=new GIFEncoder;t.setRepeat(0),t.setDelay(I.fpsRate),t.start();for(let r=0;r<T.length;r+=1)t.addFrame(T[r]);t.finish();const r=t.stream().getData(),n="data:image/gif;base64,"+encode64(r);return C.src=n,t}function X(t){const r=512/I.matrixCoefficient,n=r/2;for(let e=0;e<=512;e+=r)for(let a=0;a<=512;a+=r)t.fillStyle="rgb(76, 76, 76)",t.fillRect(e,a,n,n),t.fillRect(e+n,a+n,n,n),t.fillStyle="rgb(85, 85, 85)",t.fillRect(e,a+n,n,n),t.fillRect(e+n,a,n,n)}y.number=1,y.addEventListener("click",t=>{M(t.target.number)}),O(),S.addEventListener("click",(function(){const t=P[P.length-1].number+1,r=document.createElement("div");r.classList.add("frames__single-frame-wrapper"),r.classList.add(`frames__frame-${t}`),r.innerHTML=`<img class="frame frame-${t}" width=96 height=96><button class="frames__delete-frame-button"><img class="frames__delete-frame-image" src=${A.a} alt="delete frame button"></button>`,r.children[0].number=t,r.children[0].addEventListener("click",t=>{M(t.target.number)}),r.children[1].addEventListener("click",()=>{W(r.children[1].previousElementSibling.number)});const n=document.createElement("canvas");n.classList.add("canvas"),n.classList.add(`canvas-${t}`),n.innerHTML="Your browser doesn't support canvas!",n.setAttribute("height","512px"),n.setAttribute("width","512px"),n.number=t,I.activeCanvas=n;const e=n.getContext("2d");X(e),I.activeCanvasContext=e,N(n),G(),P.push(n),T.push(e),w.insertBefore(r,w.children[w.children.length-1]),_.appendChild(n),O(),M(t)})),k.addEventListener("click",()=>{W(k.previousElementSibling.number)}),z.addEventListener("click",()=>{C.src=q.a,setTimeout(()=>{J()},100)}),E.addEventListener("click",()=>{C.src=q.a,setTimeout(()=>{J().download("Sprite.gif")},100)}),F.addEventListener("input",()=>{I.fpsRate=Math.round(1e3/F.value),L.innerHTML=`${F.value}`})}]);